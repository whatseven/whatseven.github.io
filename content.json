[{"title":"基于python实现朴素贝叶斯算法","date":"2017-08-30T01:35:25.000Z","path":"2017/08/30/基于python实现朴素贝叶斯算法/","text":"#朴素贝叶斯算法总结下面对朴素贝叶斯算法进行粗略的总结，并可以根据这个总结搭建朴素贝叶斯算法的框架 首先，将朴素贝叶斯算法分为数据预处理-&gt;训练-&gt;识别三个模块，以下是完成Titanic预测后对算法的总结，对应的算法实现部分都有相应的实例 //Tasking图 在数据预处理部分，我们对原始数据进行预处理，将数据转化为自己想要的格式，例如 对一些属性及结果进行划分 字符串-&gt;可操作格式(例如int) 抛弃不需要的属性值 填补空缺值在完成数据预处理后，预期得到 dataMatrix矩阵：存储模型所需要数据的值，横向为不同的属性，纵向为不同的记录。 cateVec向量：存储分类结果，与dataMatrix的记录一一对应，也就是说cateVec的长度与dataMatrix的记录数相等 在训练部分，我们将dataMatrix与cateVec输入，并计算每一个划分的先验概率P（ai=j|C=k）并进行分类 通过计算一个属性的一个划分在这个类别中出现的次数除以这个类别出现的总次数得到划分的先验概率，也就是P（ai=j|C=k） 计算类别的概率P（C=k）在第一点中，我们期望得到的应该是所有属性的所有划分的概率，例如我们两个属性一个有两个划分，一个有三个划分，那一共期望的输出应该是5个概率期望输出： 有多少个类别就输出多少个字典，其中字典的key是属性与值（也就是划分），值是相应的概率，例如survived[age=1]=2/5(age=1代表age处于第一个划分) cateRate：输出类别的概率向量（P（C=k）） 识别部分，我们通过贝叶斯公式用每一个类别在训练步骤得到的字典去计算他在那一个类别的概率，通过贝叶斯公式我们了解到，这个概率为//贝叶斯公式所以在识别部分，我们将待识别的记录构造成与dataMatrix的记录格式相同的记录并作为输入： 计算输入的记录在每一个类别的后验概率（tips：通过在对应属性的dict中找到ai=j这样的记录获取相应划分的概率） 取最大值期望输出： 根据最大值输出相应的类别 至此，识别完成 Todo：将不同划分的概率值通过以[ai=j]这样的key储存在字典里效率很低，希望以后寻找到更好的解决办法 #算法实现下列算法只是粗糙的基于Python实现，使用Titanic.dat数据集，用前800条数据进行训练并用后82条数据测试，正确率为81%左右 预处理部分与前面的总结对应，首先进行数据的预处理，首先读入训练数据，定义需要输出的dataMatrix和cateVec向量12345def preProcess(): # 通过csv模块读入训练数据 reader=csv.reader(open(&quot;train.csv&quot;)) cateVec=[] dataMatrix=[] 循环train.csv的每一条数据，首先提取需要的属性并将没有值的数据设为默认值123456789for id,sur,pc,name,sex,age,sib,par,tic,fare,car,emb in reader: # 标题行跳过 if(id==&apos;PassengerId&apos;): continue # 提取需要数据 line = [pc, sex, age, sib, par] # 给空值填充值 for i in range(len(line)): if (len(line[i])==0): 将数据处理为需要的格式并处理划分12345678910111213141516171819202122232425262728293031323334#转化为需要的格式age=float(line[2])sib=int(line[3])par=int(line[4])sur=int(sur)# 划分数据ageTemp = &apos;0&apos;if 0 &lt; age and age &lt; 10: ageTemp = &apos;1&apos;elif 10 &lt;= age &lt; 20: ageTemp = &apos;2&apos;elif 20 &lt;= age &lt; 30: ageTemp = &apos;3&apos;elif 30 &lt;= age &lt; 40: ageTemp = &apos;4&apos;elif age &gt;= 40: ageTemp = &apos;5&apos;sibspTemp = &apos;0&apos;if sib == 1: sibspTemp = &apos;1&apos;elif sib == 2: sibspTemp = &apos;2&apos;elif sib &gt; 2: sibspTemp = &apos;3&apos;parchTemp = &apos;0&apos;if par == 1: parchTemp = &apos;1&apos;elif par == 2: parchTemp = &apos;2&apos;elif par &gt; 2: parchTemp = &apos;3&apos; 将类别加入类别集合，每一条处理完的数据加入数据矩阵,最后返回123 cateVec.append(sur) dataMatrix.append([pc, &apos;1&apos; if sex == &apos;male&apos; else &apos;0&apos;, ageTemp, sibspTemp, parchTemp])return data,surRate,cateVec 训练部分下列是识别部分","tags":[{"name":"Machine Lerning","slug":"Machine-Lerning","permalink":"http://http://blog.llsevenr.cn/tags/Machine-Lerning/"},{"name":"Python","slug":"Python","permalink":"http://http://blog.llsevenr.cn/tags/Python/"}]},{"title":"搭建Git服务器及多人协作开发常见命令","date":"2017-08-10T10:35:59.000Z","path":"2017/08/10/搭建Git服务器及多人协作开发常见命令/","text":"搭建Git服务器Github的项目必须为开放的并且在中国的访问速度如无特殊配置通常访问很慢，于是便想在自己的服务器上搭建Git仓库，同时也具备多人协作开发的能力。 配置Git和用户首先安装Git sudo apt install git 配置单独用来访问仓库的git用户 12groupadd gitadduser git -g git 创建SSL证书登录在支持bash的命令行下，输入 ssh-keygen -C &#39;your@email.com&#39; -t rsa 为你生成rsa密钥，可以直接一路回车，执行默认操作，生成的密钥可以在这儿找到123C://users//&lt;电脑账户名&gt;//.ssh├── id_rsa└── id_rsa.pub #公钥 服务端需要里边内容验证连接着身份 将SSH添加到管理 ssh-add id_rsa 将公钥里面的内容完整输入至/home/git/.ssh/authorized_keys，一行一个密钥 Tips：多公钥管理在.ssh目录下配置config文件，再将SSH加入SSH管理，格式如下：12345Host github.com //连接域名 HostName github.com //域名名称 User whatseven //用户 IdentityFile C:\\Users\\whatseven\\.ssh\\id_rsa_github //对应私钥 PreferredAuthentications publickey Git多人协作开发常用命令完成上述步骤，就能够在自己的服务器上建立仓库并且作为远程分支与本地分支建立联系了，下面是在多人协作开发的一些常用的Git命令。 建立裸仓库在建好的服务器里新建文件夹，在文件夹下使用git init --bare新建裸仓库，只存放版本库信息。 开发人员A上用git clone 仓库地址 仓库在本机的命名克隆仓库，开始自己的本地开发。 Tips：为什么要建立裸仓库？在Git中，如果向普通代码仓库push的话，Git会将推送的内容与工作文件进行比较，它会认为工作文件发生改变，从而影响工作树，常见的是在想远程目标的当前分支push代码时，在远程终端必须使用git reset --hard。而裸代码仓库由于没有工作树，所以push所含的变化仅影响裸代码仓库的版本控制。 在裸仓库中，工作目录下除了版本库信息没有任何东西，会给大家造成一个误解以为裸仓库只记录版本，没有文件。其实在Git系统中，文件是通过不同的对象例如索引，树，块存与版本库里面的，所以裸仓库看似工作目录是空的，在克隆裸仓库是git会将对象从版本库取出并根据版本更改信息组织到正确的位置 在开发过程中，一般会将项目分为几个分支。 Git分支策略 Git分支策略 master分支应该保存重大的版本或节点，开发前应保持远程与本地同步 dev是日常开发分支，平时的开发应在dev上进行，开发前应保持远程与本地同步 剩下的是个人分支，个人的开发在个人分支上进行，在每天或者一个阶段的工作结束后每个人将自己的代码合并到dev分支上。个人分支不用同步至远程分支 开发实例下面通过两个开发人员实例演示多人开发： 开发人员A通过git clone git@111.111.111.111:/home/git/repo/test.git test.git将远程的版本库克隆至本机 如无dev分支，A通过git checkout -b dev从master分支创建dev分支 A再次通过git checkout -b A从dev分支上创建自己的开发分支 A在工作目录里新建内容为”A”的A.txt，再创建内容为”公共”的公共.txt A通过git add A.txt 公共.txt与git commit -m &quot;init A,公共&quot;提交更改 当A完成阶段性工作后，通过git checkout dev切换至开发分支，再通过git merge --no-ff A将A分支合并到dev分支,如有冲突则在文件中去删除多余部分 A剩下的工作是要将自己的工作推到大家代码的源头–位于远程的裸仓库中，在Git中，本机Git版本库与远程库的连接是基于分支的，例如本机的master与远程的master有一条链接，本机的dev也应该与远程dev有一个链接。 A通过在dev分支上git push -u origin dev将本机的dev分支的更新推送到远程dev分支上去，-u选项是指在未建立链接的情况下建立一条链接，以后推送更新就只用git push即可 此时，A的工作已经全部做完了，当B开始工作时，他必须获取远程库的最新情况以保证自己的工作是建立在最新的工作上的，它可以在建立了链接的情况下通过git pull将远程更新拉到本地，后续操作类似A。","tags":[{"name":"Git","slug":"Git","permalink":"http://http://blog.llsevenr.cn/tags/Git/"},{"name":"分支策略","slug":"分支策略","permalink":"http://http://blog.llsevenr.cn/tags/分支策略/"}]},{"title":"JavaScript常见集合操作","date":"2017-08-09T13:37:20.000Z","path":"2017/08/09/JavaScript常见集合操作/","text":"集合的遍历for循环(效率最高) 优点：JavaScript最普遍的for循环，执行效率最高 缺点：无法遍历对象 123for(let i=0;i&lt;array.length,i++)&#123; //operation&#125; for…in循环(效率较低) 优点：唯一一个能够获取对象的属性名的遍历方式 缺点：会将对象通过继承得到的属性一齐遍历，造成非预料的结果且效率较低 1234//会访问非继承的属性for(attr in object)&#123;//attr作为属性名 //object[attr]访问值&#125; 123456//避免访问继承的属性for(attr in object)&#123;//attr作为属性名 if(object.hasOwnProperty(attr))&#123; //object[attr]访问值 &#125;&#125; for…of循环(效率较高) 优点：能够快速访问非继承属性值 缺点：需要ES6支持 123for(item of object)&#123; //item访问值&#125; forEach方法(数组内置高阶方法，含义清晰) 优点：函数式编程，简洁，快速领会代码含义 缺点：无法对对象使用 12345array.forEach(function(item,index,array))&#123; //item为值 //index为索引 //array为被访问数组&#125;; Tips: 在对对象进行遍历时，如不需要访问属性名选择for...of循环，如需访问属性名选择for...in循环 在对数组进行访问时，使用forEach得到较好的可读性，传统的for循环能够带来很高的性能及拓展性 集合的操作在小波老师提倡的想机器一样思考中，编程问题的解决被分为了输入，处理和输出 像机器一样思考 引用自像机器一样思考（一）—— 宏观的基础 处理，是对输入数据的处理，就可以分为从输入的数据中提炼出一定的有价值的数据，并对他们做出一些操作，得到希望得到的有价值的东西，并将他输出 Map映射Map映射是将输入的数据中有价值的东西提取出来，转化为更有利于处理的格式123456let dataAfterProcess = array.map(function(item,index,array)&#123; //item为值 //index为索引 //array为被访问数组 return ;//返回dataAfterProcess中希望被添加的元素&#125;); Reduce计算Reduce计算以提取好的数据输入，并获得最终的一个结果1234567let output = array.reduce(function(accumulator, currentValue, currentIndex, array)&#123; //accumulator为输出结果 //currentValue为遍历数组目前的值 //currentIndex为遍历数组目前的索引 //array为被访问数组 return ;//返回希望累加的操作&#125;,0);//0为计算结果的初始值，默认为数组第一个元素 TODO在完成JS练习中，我时常会遇到以下问题待解决： 在Map操作中，经常会遇到需要根据已有的目标数组的情况做出相应的映射操作，但目前尚未发现怎样在Map循环中检查已映射的目标数组 为对象实现接口使对象也具有MapReduce操作的能力","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://http://blog.llsevenr.cn/tags/JavaScript/"},{"name":"collection","slug":"collection","permalink":"http://http://blog.llsevenr.cn/tags/collection/"},{"name":"集合","slug":"集合","permalink":"http://http://blog.llsevenr.cn/tags/集合/"},{"name":"遍历","slug":"遍历","permalink":"http://http://blog.llsevenr.cn/tags/遍历/"}]}]