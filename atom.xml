<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>whatseven的博客</title>
  <subtitle>blog</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://http://blog.llsevenr.cn/"/>
  <updated>2017-09-27T04:00:54.389Z</updated>
  <id>http://http://blog.llsevenr.cn/</id>
  
  <author>
    <name>whatseven</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>在线编程环境CHE的配置</title>
    <link href="http://http://blog.llsevenr.cn/2017/09/27/%E5%9C%A8%E7%BA%BF%E7%BC%96%E7%A8%8B%E7%8E%AF%E5%A2%83CHE%E7%9A%84%E9%85%8D%E7%BD%AE/"/>
    <id>http://http://blog.llsevenr.cn/2017/09/27/在线编程环境CHE的配置/</id>
    <published>2017-09-27T04:00:15.000Z</published>
    <updated>2017-09-27T04:00:54.389Z</updated>
    
    <content type="html"><![CDATA[<h1 id="修改CHE配置"><a href="#修改CHE配置" class="headerlink" title="修改CHE配置"></a>修改CHE配置</h1><p><strong>需要工具</strong></p>
<ul>
<li><p>Xshell·<a href="http://jingyan.baidu.com/article/295430f13fb4db0c7f005065.html" target="_blank" rel="external">教程</a></p>
<p>  <strong>也可以用Putty+Winscp</strong></p>
</li>
<li>配置脚本·<a href="http://otbwgn2nv.bkt.clouddn.com/changeHostIP.sh" target="_blank" rel="external">下载</a></li>
</ul>
<h2 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h2><p>首先需要修改<code>che.env</code>文件，将里面的IP地址设为自己服务器的公网IP地址</p>
<ul>
<li><p>打开<code>Xshell</code>，输入服务器的公网IP并连接，并输入账号密码，默认进入<code>~</code>目录</p>
<p>  <img src="http://otbwgn2nv.bkt.clouddn.com/5bfc64ee548e669975726924884905fc.png" alt="tws-che教程"></p>
</li>
<li><p>从登入服务器的<code>~</code>目录进入配置文件所在目录</p>
<p>  <code>cd EclipseChe</code></p>
<p>  <code>ls -l</code></p>
<p>  可以看到如下输出</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">drwxr-xr-x 2 root root  4096 Sep 26 18:49 backup</div><div class="line">-rw-r--r-- 1 root root 24015 Sep 26 19:42 che.env</div><div class="line">-rw-r--r-- 1 root root 14192 Sep 26 20:02 cli.log</div><div class="line">drwxr-xr-x 2 root root  4096 Sep 26 18:52 docs</div><div class="line">drwxr-xr-x 6 root root  4096 Sep 26 18:52 instance</div></pre></td></tr></table></figure>
<p>  其中<code>che.env</code>是我们需要修改的文件</p>
</li>
<li><p>为方便同学更改文件，我们已经将更改操作编辑为脚本，点击下载<a href="http://otbwgn2nv.bkt.clouddn.com/changeHostIP.sh" target="_blank" rel="external">脚本</a></p>
</li>
<li><p>打开<code>Xshell</code>，点击新建文件传输，进入到<code>~/EclipseChe/</code>目录下，输入<code>put</code>命令，在弹出的对话框选择下载到本地的脚本，将他上传至<code>~/EclipseChe/</code>目录下</p>
<p>  <img src="http://otbwgn2nv.bkt.clouddn.com/9529022cd0b7eff9cbe13994f5e02612.png" alt="tws-配置教程"></p>
</li>
<li><p>在<code>Xshell</code>中切换到刚刚的ssh的窗口查看脚本并输入<code>chmod +x changeHostIP.sh</code>赋予脚本执行权限</p>
</li>
<li><p>输入<code>./changeHostIP.sh</code>运行脚本，会被问及自己的公网IP，输入自己的公网IP后回车</p>
  <figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">$ ./test.sh</div><div class="line">请输入你的公网IP</div><div class="line">111.222.333.444</div></pre></td></tr></table></figure>
</li>
<li><p>静静的等待<code>che</code>重启成功，大概五分钟左右</p>
</li>
</ul>
<h2 id="添加workspace"><a href="#添加workspace" class="headerlink" title="添加workspace"></a>添加workspace</h2><p>第二步我们需要添加自己的workspace，打开浏览器，输入自己的公网<code>IP地址:8080</code>访问<code>che</code>的管理界面,例如<code>111.222.333.444:8080</code></p>
<ul>
<li><p>在左边的菜单栏选择<code>WorkSpaces</code></p>
</li>
<li><p>单击<code>Add WorkSpace</code></p>
</li>
<li><p>在<code>SELECT STACK</code>下，将滚动条拉到最下面选择本次训练营主要用到的<code>tws-node-7</code>这一个环境</p>
</li>
</ul>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://otbwgn2nv.bkt.clouddn.com/b8fd38c5f6f1ead157575385a7b1a7e4.png" alt="tes-workspace" title="">
                </div>
                <div class="image-caption">tes-workspace</div>
            </figure>
<ul>
<li>单击网页下侧的绿色按钮<code>CREATE</code>完成配置</li>
</ul>
<p>然后选择左侧的新建的workspace就可以开始体验在线编程环境了~</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;修改CHE配置&quot;&gt;&lt;a href=&quot;#修改CHE配置&quot; class=&quot;headerlink&quot; title=&quot;修改CHE配置&quot;&gt;&lt;/a&gt;修改CHE配置&lt;/h1&gt;&lt;p&gt;&lt;strong&gt;需要工具&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Xshell·&lt;a hr
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>用OpenCV进行相机标定</title>
    <link href="http://http://blog.llsevenr.cn/2017/09/01/%E7%94%A8OpenCV%E8%BF%9B%E8%A1%8C%E7%9B%B8%E6%9C%BA%E6%A0%87%E5%AE%9A/"/>
    <id>http://http://blog.llsevenr.cn/2017/09/01/用OpenCV进行相机标定/</id>
    <published>2017-09-01T10:50:13.000Z</published>
    <updated>2017-09-01T14:43:54.634Z</updated>
    
    <content type="html"><![CDATA[<h1 id="相机标定的原理"><a href="#相机标定的原理" class="headerlink" title="相机标定的原理"></a>相机标定的原理</h1><h2 id="成像模型"><a href="#成像模型" class="headerlink" title="成像模型"></a>成像模型</h2><p>相机在计算机视觉应用中起着重要作用，作为图像数据来源，影响着后续各个处理步骤。成像模型就是用数学公式刻画整个成像过程，即被拍摄物体空间点到照片成像点之间的几何变换关系。</p>
<p>总体上，相机成像可以分为四个步骤：刚体变换、透视投影、畸变校正和数字化图像。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://otbwgn2nv.bkt.clouddn.com/34b5e49d0d138be3658b2159e7bb5a75.png" alt="相机成像模型" title="">
                </div>
                <div class="image-caption">相机成像模型</div>
            </figure>
<h3 id="刚体变换"><a href="#刚体变换" class="headerlink" title="刚体变换"></a>刚体变换</h3><p>刚体变换只改变物体的空间位置(平移)和朝向(旋转)，而不改变其形状，可用两个变量来描述：旋转矩阵R和平移向量t</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://otbwgn2nv.bkt.clouddn.com/1ac9d44f769814d43792588d48c5ce3a.png" alt="刚体变换" title="">
                </div>
                <div class="image-caption">刚体变换</div>
            </figure>
<p>齐次坐标下可写为：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://otbwgn2nv.bkt.clouddn.com/a38e43248e0052a0300c4e1952f815ad.png" alt="刚体变换" title="">
                </div>
                <div class="image-caption">刚体变换</div>
            </figure>
<p>旋转矩阵R是正交矩阵，可通过罗德里格斯（Rodrigues）变换转换为只有三个独立变量的旋转向量：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://otbwgn2nv.bkt.clouddn.com/7e4b581b5276314cf76a148e0be3832d.png" alt="Rodrigues" title="">
                </div>
                <div class="image-caption">Rodrigues</div>
            </figure>
<p>因此，刚体变换可用6个参数来描述，这6个参数就称为相机的外参(Extrinsic)，相机外参决定了空间点从世界坐标系转换到相机坐标系的变换，也可以说外参描述了相机在世界坐标系中的位置和朝向。</p>
<h3 id="透视投影"><a href="#透视投影" class="headerlink" title="透视投影"></a>透视投影</h3><p>我们可以将透镜的成像简单地抽象成下图所示：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://otbwgn2nv.bkt.clouddn.com/8e161a5c59f4dd7b03171e037a7fa475.png" alt="透视投影" title="">
                </div>
                <div class="image-caption">透视投影</div>
            </figure>
<p>设 f=OB 表示透镜的焦距，m=OC 为像距，n=AO 为物距，有：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://otbwgn2nv.bkt.clouddn.com/2c2568cb708d6d0b0f51b9828ea8f7ee.png" alt="焦距" title="">
                </div>
                <div class="image-caption">焦距</div>
            </figure>
<p>一般地，由于物距远大于焦距，即 n&gt;&gt;f，所以 m≈f，此时可以用小孔模型代替透镜成像：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://otbwgn2nv.bkt.clouddn.com/0f71e4f9c80acc9adc065707d2d3f775.png" alt="小孔成像" title="">
                </div>
                <div class="image-caption">小孔成像</div>
            </figure>
<p>可得：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://otbwgn2nv.bkt.clouddn.com/584e9339e90f767d3647d336babfe443.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>齐次坐标下有：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://otbwgn2nv.bkt.clouddn.com/26d8e6748631307ab47a3ab323c6f13f.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>如果将成像平面移到相机光心与物体之间，则有中心透视模型：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://otbwgn2nv.bkt.clouddn.com/c7d090d8018cfae40527a6f5d0e5feb9.png" alt="小孔" title="">
                </div>
                <div class="image-caption">小孔</div>
            </figure>
<p>可得：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://otbwgn2nv.bkt.clouddn.com/2780c41b044b11200613f679c97ec9c4.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>齐次坐标下有：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://otbwgn2nv.bkt.clouddn.com/3b7c10969a79e2c92611b1343c32aa89.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>总体上看，透视投影将相机坐标系中的点投影到理想图像坐标系，其变换过程只与相机焦距 f 有关。</p>
<h3 id="畸变校正"><a href="#畸变校正" class="headerlink" title="畸变校正"></a>畸变校正</h3><p>理想的针孔成像模型确定的坐标变换关系均为线性的，而实际上，现实中使用的相机由于镜头中镜片因为光线的通过产生的不规则的折射，镜头畸变（lens distortion）总是存在的，即根据理想针孔成像模型计算出来的像点坐标与实际坐标存在偏差。畸变的引入使得成像模型中的几何变换关系变为非线性，增加了模型的复杂度，但更接近真实情形。畸变导致的成像失真可分为径向失真和切向失真两类：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://otbwgn2nv.bkt.clouddn.com/50da8ca21000a23c748c76ef05c11352.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>畸变类型很多，总体上可分为径向畸变和切向畸变两类，径向畸变的形成原因是镜头制造工艺不完美，使得镜头形状存在缺陷，包括枕形畸变和桶形畸变等，可以用如下表达式来描述：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://otbwgn2nv.bkt.clouddn.com/8d8ed2c69ab681cbf26e1107aae6f1ef.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>切向畸变又分为薄透镜畸变和离心畸变等，薄透镜畸变则是因为透镜存在一定的细微倾斜造成的；离心畸变的形成原因是镜头是由多个透镜组合而成的，而各个透镜的光轴不在同一条中心线上。切向畸变可以用如下数学表达式来描述：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://otbwgn2nv.bkt.clouddn.com/cb54b83eaf68817ae74384c6fb03696d.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>在引入镜头的畸变后，成像点从理想图像坐标系到真实图像坐标系的变换关系可以表示为：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://otbwgn2nv.bkt.clouddn.com/95a39188156939dab30d20ad4a418cac.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>实际计算过程中，如果考虑太多高阶的畸变参数，会导致标定求解的不稳定。</p>
<h3 id="数字化图像"><a href="#数字化图像" class="headerlink" title="数字化图像"></a>数字化图像</h3><p>光线通过相机镜头后最终成像在感光阵列(CCD或CMOS)上，然后感光阵列将光信号转化为电信号，最后形成完整的图像。我们用dx和dy分别表示感光阵列的每个点在x和y方向上物理尺寸，即一个像素是多少毫米，这两个值一般比较接近，但由于制造工艺的精度问题，会有一定误差，同样的，感光阵列的法向和相机光轴也不是完全重合，即可以看作成像平面与光轴不垂直。<br><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://otbwgn2nv.bkt.clouddn.com/8d88f7c57ed53c087c9d2138c43f08e6.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure></p>
<p>我们用仿射变换来描述这个过程，如上图，O点是图像中心点，对应图像坐标(u0，v0)，Xd - Yd是真实图像坐标系，U-V是数字化图像坐标系，有：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://otbwgn2nv.bkt.clouddn.com/ef4348cdde922a5537937d10821cc703.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>齐次坐标下有：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://otbwgn2nv.bkt.clouddn.com/b749d14c0e8c5d9072682ea7f9b0f868.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>上式中的变换矩阵即为相机的内参数矩阵 K，其描述了相机坐标系中点到二维图像上点的变换过程。</p>
<p>综上所述，在不考虑镜头畸变的情况下，相机的整个成像过程可表示为，其中R,T为旋转矩阵和平移矩阵，为相机的外参数：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://otbwgn2nv.bkt.clouddn.com/4d8fa276198b8e4437e8b4f7048cb349.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p>若考虑畸变，则为</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://otbwgn2nv.bkt.clouddn.com/459e6e6b8ff1fb1cd8a529b6abaa2a0a.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<h1 id="相机标定的步骤"><a href="#相机标定的步骤" class="headerlink" title="相机标定的步骤"></a>相机标定的步骤</h1><ol>
<li>准备标定图片</li>
<li>对每一张标定图片，提取角点信息</li>
<li>对每一张标定图片，进一步提取亚像素角点信息</li>
<li>相机标定</li>
<li>查看标定效果——利用标定结果对棋盘图进行矫正</li>
</ol>
<h1 id="基于OpenCV的相机标定实现"><a href="#基于OpenCV的相机标定实现" class="headerlink" title="基于OpenCV的相机标定实现"></a>基于OpenCV的相机标定实现</h1><h2 id="定义全局变量"><a href="#定义全局变量" class="headerlink" title="定义全局变量"></a>定义全局变量</h2><p><strong>首先定义全局变量</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line">#include &quot;opencv2/core/core.hpp&quot;</div><div class="line">#include &quot;opencv2/imgproc/imgproc.hpp&quot;</div><div class="line">#include &quot;opencv2/calib3d/calib3d.hpp&quot;</div><div class="line">#include &quot;opencv2/highgui/highgui.hpp&quot;</div><div class="line">#include &lt;iostream&gt;</div><div class="line">#include &lt;fstream&gt;</div><div class="line">#include &quot;Calibration.h&quot;</div><div class="line"></div><div class="line">using namespace cv;</div><div class="line">using namespace std;</div><div class="line"></div><div class="line">int image_count = 0;						// 图像数量</div><div class="line">Size board_size = Size(6, 4);				// 标定板上每行、列的角点数</div><div class="line"></div><div class="line">Size image_size;											// 图像的尺寸</div><div class="line">vector&lt;vector&lt;Point2f&gt;&gt; image_points_seq;					// 保存检测到的所有角点</div><div class="line">Mat cameraMatrix = Mat(3, 3, CV_32FC1, Scalar::all(0));		// 摄像机内参数矩阵</div><div class="line">Mat distCoeffs = Mat(1, 5, CV_32FC1, Scalar::all(0));		// 摄像机的5个畸变系数：k1,k2,p1,p2,k3</div><div class="line"></div><div class="line">void findCheese(string filename);</div><div class="line">void myCalibration(string filename);</div><div class="line">void correctFile();</div></pre></td></tr></table></figure></p>
<h2 id="读入图片并寻找角点"><a href="#读入图片并寻找角点" class="headerlink" title="读入图片并寻找角点"></a>读入图片并寻找角点</h2><p><strong>然后读入储存图片路径的文本文件，读入图片并且寻找图片角点</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div></pre></td><td class="code"><pre><div class="line">void findCheese(string filename) &#123;</div><div class="line">	vector&lt;Point2f&gt; image_points_buf;  // 缓存每幅图像上检测到的角点</div><div class="line">	cout &lt;&lt; &quot;开始提取角点&quot;;</div><div class="line">	ifstream fin(filename);</div><div class="line"></div><div class="line">	while (getline(fin, filename))</div><div class="line">	&#123;</div><div class="line">		image_count++;</div><div class="line">		cout &lt;&lt; &quot;Solve image = &quot; &lt;&lt; image_count &lt;&lt; endl;</div><div class="line">		Mat imageInput = imread(filename);</div><div class="line">		if (image_count == 1)  //读入第一张图片时获取图像宽高信息,标定需要</div><div class="line">		&#123;</div><div class="line">			image_size.width = imageInput.cols;</div><div class="line">			image_size.height = imageInput.rows;</div><div class="line">			cout &lt;&lt; &quot;image_size.width = &quot; &lt;&lt; image_size.width &lt;&lt; endl;</div><div class="line">			cout &lt;&lt; &quot;image_size.height = &quot; &lt;&lt; image_size.height &lt;&lt; endl;</div><div class="line">		&#125;</div><div class="line"></div><div class="line">		/* 提取角点 */</div><div class="line">		if (0 == findChessboardCorners(imageInput, board_size, image_points_buf))</div><div class="line">		&#123;</div><div class="line">			cout &lt;&lt; &quot;can not find chessboard corners!\n&quot;; //找不到角点</div><div class="line">			exit(1);</div><div class="line">		&#125;</div><div class="line">		else</div><div class="line">		&#123;</div><div class="line">			Mat view_gray;</div><div class="line">			cvtColor(imageInput, view_gray, CV_RGB2GRAY);</div><div class="line">			/* 亚像素精确化 */</div><div class="line">			find4QuadCornerSubpix(view_gray, image_points_buf, Size(5, 5)); //对粗提取的角点进行精确化</div><div class="line">																			//cornerSubPix(view_gray,image_points_buf,Size(5,5),Size(-1,-1),TermCriteria(CV_TERMCRIT_EPS+CV_TERMCRIT_ITER,30,0.1));</div><div class="line">			image_points_seq.push_back(image_points_buf);  //保存亚像素角点</div><div class="line"></div><div class="line">			//drawChessboardCorners(view_gray, board_size, image_points_buf, false); //用于在图片中标记角点</div><div class="line">			//imshow(&quot;Camera Calibration&quot;, view_gray);//显示图片</div><div class="line">			//waitKey(500);//暂停0.5S		</div><div class="line">		&#125;</div><div class="line">	&#125;</div><div class="line">	cout &lt;&lt; &quot;角点提取完成！\n&quot;;</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<h2 id="进行标定，寻找内参数与畸变参数"><a href="#进行标定，寻找内参数与畸变参数" class="headerlink" title="进行标定，寻找内参数与畸变参数"></a>进行标定，寻找内参数与畸变参数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div></pre></td><td class="code"><pre><div class="line">void myCalibration(string filename) &#123;</div><div class="line"></div><div class="line">	cout &lt;&lt; &quot;开始标定………………&quot;;</div><div class="line">	/*棋盘三维信息*/</div><div class="line">	Size square_size = Size(10, 10);  /* 实际测量得到的标定板上每个棋盘格的大小 */</div><div class="line">	vector&lt;vector&lt;Point3f&gt;&gt; object_points; /* 保存标定板上角点的三维坐标 */</div><div class="line">	vector&lt;Mat&gt; tvecsMat;  /* 每幅图像的旋转向量 */</div><div class="line">	vector&lt;Mat&gt; rvecsMat; /* 每幅图像的平移向量 */</div><div class="line">	/* 初始化标定板上角点的三维坐标 */</div><div class="line">	int i, j, t;</div><div class="line">	for (t = 0; t&lt;image_count; t++)</div><div class="line">	&#123;</div><div class="line">		vector&lt;Point3f&gt; tempPointSet;</div><div class="line">		for (i = 0; i&lt;board_size.height; i++)</div><div class="line">		&#123;</div><div class="line">			for (j = 0; j&lt;board_size.width; j++)</div><div class="line">			&#123;</div><div class="line">				Point3f realPoint;</div><div class="line">				/* 假设标定板放在世界坐标系中z=0的平面上 */</div><div class="line">				realPoint.x = i*square_size.width;</div><div class="line">				realPoint.y = j*square_size.height;</div><div class="line">				realPoint.z = 0;</div><div class="line">				tempPointSet.push_back(realPoint);</div><div class="line">			&#125;</div><div class="line">		&#125;</div><div class="line">		object_points.push_back(tempPointSet);</div><div class="line">	&#125;</div><div class="line"></div><div class="line">	/* 开始标定 */</div><div class="line">	calibrateCamera(object_points, image_points_seq, image_size, cameraMatrix, distCoeffs, rvecsMat, tvecsMat, 0);</div><div class="line">	cout &lt;&lt; &quot;标定完成！\n&quot;;</div><div class="line"></div><div class="line">	//保存标定结果  </div><div class="line">	ofstream fout(filename);  // 保存标定结果的文件</div><div class="line">	std::cout &lt;&lt; &quot;开始保存定标结果………………&quot; &lt;&lt; endl;</div><div class="line">	fout &lt;&lt; &quot;相机内参数矩阵：&quot; &lt;&lt; endl;</div><div class="line">	fout &lt;&lt; cameraMatrix &lt;&lt; endl &lt;&lt; endl;</div><div class="line">	fout &lt;&lt; &quot;畸变系数：\n&quot;;</div><div class="line">	fout &lt;&lt; distCoeffs &lt;&lt; endl &lt;&lt; endl &lt;&lt; endl;</div><div class="line"></div><div class="line">	std::cout &lt;&lt; &quot;完成保存&quot; &lt;&lt; endl;</div><div class="line">	fout &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="进行图像矫正"><a href="#进行图像矫正" class="headerlink" title="进行图像矫正"></a>进行图像矫正</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div></pre></td><td class="code"><pre><div class="line">void correctFile() &#123;</div><div class="line">	Mat mapx = Mat(image_size, CV_32FC1);</div><div class="line">	Mat mapy = Mat(image_size, CV_32FC1);</div><div class="line">	Mat R = Mat::eye(3, 3, CV_32F);</div><div class="line">	std::cout &lt;&lt; &quot;保存矫正图像&quot; &lt;&lt; endl;</div><div class="line">	string imageFileName;</div><div class="line">	std::stringstream StrStm;</div><div class="line">	for (int i = 0; i != image_count; i++)</div><div class="line">	&#123;</div><div class="line">		std::cout &lt;&lt; &quot;Save &quot; &lt;&lt; i + 1 &lt;&lt; &quot;...&quot; &lt;&lt; endl;</div><div class="line">		initUndistortRectifyMap(cameraMatrix, distCoeffs, R, cameraMatrix, image_size, CV_32FC1, mapx, mapy);</div><div class="line">		StrStm.clear();</div><div class="line">		imageFileName.clear();</div><div class="line">		string filePath = &quot;C:\\Users\\whatseven\\Desktop\\project\\C++\\Calibration\\Calibration\\image\\chess&quot;;</div><div class="line">		StrStm &lt;&lt; i + 1;</div><div class="line">		StrStm &gt;&gt; imageFileName;</div><div class="line">		filePath += imageFileName;</div><div class="line">		filePath += &quot;.bmp&quot;;</div><div class="line">		Mat imageSource = imread(filePath);</div><div class="line">		Mat newimage = imageSource.clone();</div><div class="line">		//另一种不需要转换矩阵的方式</div><div class="line">		//undistort(imageSource,newimage,cameraMatrix,distCoeffs);</div><div class="line">		remap(imageSource, newimage, mapx, mapy, INTER_LINEAR);</div><div class="line">		StrStm.clear();</div><div class="line">		filePath.clear();</div><div class="line">		StrStm &lt;&lt; i + 1;</div><div class="line">		StrStm &gt;&gt; imageFileName;</div><div class="line">		imageFileName += &quot;_d.jpg&quot;;</div><div class="line">		imwrite(imageFileName, newimage);</div><div class="line">	&#125;</div><div class="line">	std::cout &lt;&lt; &quot;保存结束&quot; &lt;&lt; endl;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="调用函数"><a href="#调用函数" class="headerlink" title="调用函数"></a>调用函数</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">void main()</div><div class="line">&#123;</div><div class="line">	string inputFile = &quot;calibdata.txt&quot;;</div><div class="line">	string outputFile = &quot;caliberation_result.txt&quot;;</div><div class="line"></div><div class="line">	findCheese(inputFile);			//找到角点</div><div class="line"></div><div class="line">	myCalibration(outputFile);		//标定，找到参数矩阵及畸变系数</div><div class="line"></div><div class="line">	correctFile();					//储存矫正后图片</div><div class="line"></div><div class="line">	return;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="标定结果"><a href="#标定结果" class="headerlink" title="标定结果"></a>标定结果</h2><figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://otbwgn2nv.bkt.clouddn.com/c28b1b2342c202e556e4cc31b1a646fd.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
<p><strong><a href="https://github.com/whatseven/Calibration.git" target="_blank" rel="external">Github项目地址</a></strong></p>
<h1 id="利用Matlab进行标定"><a href="#利用Matlab进行标定" class="headerlink" title="利用Matlab进行标定"></a>利用Matlab进行标定</h1><h2 id="CameraCalibrator工具"><a href="#CameraCalibrator工具" class="headerlink" title="CameraCalibrator工具"></a>CameraCalibrator工具</h2><ol>
<li><p>在Matlab命令行里，输入<code>cameraCalibrator</code>打开标定程序</p>
</li>
<li><p>选择<code>Add images</code>将图片导入</p>
</li>
<li><p>单击<code>Calibration</code>即可开始标定，再点击<code>Export Camera Parameters</code>即可导出相机参数</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://otbwgn2nv.bkt.clouddn.com/32b1e24f203e5bbad6795546093b9db7.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>
</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;相机标定的原理&quot;&gt;&lt;a href=&quot;#相机标定的原理&quot; class=&quot;headerlink&quot; title=&quot;相机标定的原理&quot;&gt;&lt;/a&gt;相机标定的原理&lt;/h1&gt;&lt;h2 id=&quot;成像模型&quot;&gt;&lt;a href=&quot;#成像模型&quot; class=&quot;headerlink&quot; titl
    
    </summary>
    
    
      <category term="Computer Vision" scheme="http://http://blog.llsevenr.cn/tags/Computer-Vision/"/>
    
  </entry>
  
  <entry>
    <title>基于python实现朴素贝叶斯算法</title>
    <link href="http://http://blog.llsevenr.cn/2017/08/30/%E5%9F%BA%E4%BA%8Epython%E5%AE%9E%E7%8E%B0%E6%9C%B4%E7%B4%A0%E8%B4%9D%E5%8F%B6%E6%96%AF%E7%AE%97%E6%B3%95/"/>
    <id>http://http://blog.llsevenr.cn/2017/08/30/基于python实现朴素贝叶斯算法/</id>
    <published>2017-08-30T01:35:25.000Z</published>
    <updated>2017-09-01T14:45:11.944Z</updated>
    
    <content type="html"><![CDATA[<h1 id="朴素贝叶斯算法总结"><a href="#朴素贝叶斯算法总结" class="headerlink" title="朴素贝叶斯算法总结"></a>朴素贝叶斯算法总结</h1><p>(有关朴素贝叶斯算法的原理可可参考<a href="http://www.cnblogs.com/leoo2sk/archive/2010/09/17/naive-bayesian-classifier.html" target="_blank" rel="external">算法杂货铺——分类算法之朴素贝叶斯分类(Naive Bayesian classification)</a>)</p>
<p>下面对朴素贝叶斯算法进行粗略的总结，并可以根据这个总结搭建朴素贝叶斯算法的框架</p>
<p>首先，将朴素贝叶斯算法分为<code>数据预处理-&gt;训练-&gt;识别三个模块</code>，以下是完成Titanic预测后对算法的总结，<strong>对应的算法实现部分都有相应的实例</strong></p>
<p>//Tasking图</p>
<p>在数据预处理部分，我们对原始数据进行预处理，将数据转化为自己想要的格式，例如</p>
<ul>
<li>对一些属性及结果进行划分</li>
<li>字符串-&gt;可操作格式(例如int)</li>
<li>抛弃不需要的属性值</li>
<li>填补空缺值<br>在完成数据预处理后，预期得到</li>
<li><code>dataMatrix</code>矩阵：存储模型所需要数据的值，横向为不同的属性，纵向为不同的记录。</li>
<li><code>cateVec</code>向量：存储分类结果，与<code>dataMatrix</code>的记录一一对应，也就是说<code>cateVec</code>的长度与<code>dataMatrix</code>的记录数相等</li>
</ul>
<p>在训练部分，我们将<code>dataMatrix</code>与<code>cateVec</code>输入，并计算每一个划分的先验概率<code>P（ai=j|C=k）</code>并进行分类</p>
<ul>
<li>通过计算一个属性的一个划分在这个类别中出现的次数除以这个类别出现的总次数得到划分的先验概率，也就是<code>P（ai=j|C=k）</code></li>
<li>计算类别的概率<code>P（C=k）</code><br>在第一点中，我们期望得到的应该是<strong>所有属性的所有划分的概率</strong>，例如我们两个属性一个有两个划分，一个有三个划分，那一共期望的输出应该是5个概率<br>期望输出：</li>
<li>有多少个类别就输出多少个字典，其中字典的<code>key</code>是属性与值（也就是划分），值是相应的概率，例如<code>survived[age=1]=2/5(age=1代表age处于第一个划分)</code></li>
<li><code>cateRate</code>：输出类别的概率向量<code>（P（C=k））</code></li>
</ul>
<p>识别部分，我们通过贝叶斯公式用每一个类别在训练步骤得到的字典去计算他在那一个类别的概率，通过贝叶斯公式我们了解到，这个概率为<br>//贝叶斯公式<br>所以在识别部分，我们将待识别的记录构造成与<code>dataMatrix</code>的记录格式相同的记录并作为输入：</p>
<ul>
<li>计算输入的记录在每一个类别的后验概率（tips：通过在对应属性的<code>dict</code>中找到<code>ai=j</code>这样的记录获取相应划分的概率）</li>
<li>取最大值<br>期望输出：</li>
<li>根据最大值输出相应的类别</li>
</ul>
<p>至此，识别完成</p>
<p>Todo：将不同划分的概率值通过以<code>[ai=j]</code>这样的key储存在字典里效率很低，希望以后寻找到更好的解决办法</p>
<h1 id="算法实现"><a href="#算法实现" class="headerlink" title="算法实现"></a>算法实现</h1><p>下列算法只是粗糙的基于<code>Python</code>实现，使用<code>Titanic.dat</code>数据集，用前800条数据进行训练并用后82条数据测试，正确率为81%左右</p>
<h2 id="预处理部分"><a href="#预处理部分" class="headerlink" title="预处理部分"></a>预处理部分</h2><p>与前面的总结对应，首先进行数据的预处理，首先<strong>读入训练数据，定义需要输出的<code>dataMatrix</code>和<code>cateVec</code>向量</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">def preProcess():</div><div class="line">    # 通过csv模块读入训练数据</div><div class="line">    reader=csv.reader(open(&quot;train.csv&quot;))</div><div class="line">    cateVec=[]</div><div class="line">    dataMatrix=[]</div></pre></td></tr></table></figure></p>
<p><strong>循环train.csv的每一条数据，首先提取需要的属性并将没有值的数据设为默认值</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">for id,sur,pc,name,sex,age,sib,par,tic,fare,car,emb in reader:</div><div class="line">    # 标题行跳过</div><div class="line">    if(id==&apos;PassengerId&apos;):</div><div class="line">        continue</div><div class="line">    # 提取需要数据</div><div class="line">    line = [pc, sex, age, sib, par]</div><div class="line">    # 给空值填充值</div><div class="line">    for i in range(len(line)):</div><div class="line">        if (len(line[i])==0):</div></pre></td></tr></table></figure></p>
<p><strong>将数据处理为需要的格式并处理划分</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div></pre></td><td class="code"><pre><div class="line">#转化为需要的格式</div><div class="line">age=float(line[2])</div><div class="line">sib=int(line[3])</div><div class="line">par=int(line[4])</div><div class="line">sur=int(sur)</div><div class="line"></div><div class="line"># 划分数据</div><div class="line">ageTemp = &apos;0&apos;</div><div class="line">if 0 &lt; age and age &lt; 10:</div><div class="line">    ageTemp = &apos;1&apos;</div><div class="line">elif 10 &lt;= age &lt; 20:</div><div class="line">    ageTemp = &apos;2&apos;</div><div class="line">elif 20 &lt;= age &lt; 30:</div><div class="line">    ageTemp = &apos;3&apos;</div><div class="line">elif 30 &lt;= age &lt; 40:</div><div class="line">    ageTemp = &apos;4&apos;</div><div class="line">elif age &gt;= 40:</div><div class="line">    ageTemp = &apos;5&apos;</div><div class="line"></div><div class="line">sibspTemp = &apos;0&apos;</div><div class="line">if sib == 1:</div><div class="line">    sibspTemp = &apos;1&apos;</div><div class="line">elif sib == 2:</div><div class="line">    sibspTemp = &apos;2&apos;</div><div class="line">elif sib &gt; 2:</div><div class="line">    sibspTemp = &apos;3&apos;</div><div class="line"></div><div class="line">parchTemp = &apos;0&apos;</div><div class="line">if par == 1:</div><div class="line">    parchTemp = &apos;1&apos;</div><div class="line">elif par == 2:</div><div class="line">    parchTemp = &apos;2&apos;</div><div class="line">elif par &gt; 2:</div><div class="line">    parchTemp = &apos;3&apos;</div></pre></td></tr></table></figure></p>
<p><strong>将类别加入类别集合，每一条处理完的数据加入数据矩阵,最后返回</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">    cateVec.append(sur)</div><div class="line">    dataMatrix.append([pc, &apos;1&apos; if sex == &apos;male&apos; else &apos;0&apos;, ageTemp, sibspTemp, parchTemp])</div><div class="line">return dataMatrix,cateVec</div></pre></td></tr></table></figure></p>
<h2 id="训练部分"><a href="#训练部分" class="headerlink" title="训练部分"></a>训练部分</h2><p>下列是训练部分<br><strong>首先算出需要输出的类别概率<code>P（C=0）</code></strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">def train(data, cateVec):</div><div class="line">    # 类别概率（P（C=0））</div><div class="line">    surRate=sum(cateVec)/len(cateVec)</div></pre></td></tr></table></figure></p>
<p><strong>然后循环计算需要输出的每个划分出现的次数</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"># 不同类别下不同划分的次数</div><div class="line">surVec=&#123;&#125;</div><div class="line">unsurVec=&#123;&#125;</div><div class="line"># 循环dataMatrix里的每一个属性，根据不同的类别统计其对应的划分的次数</div><div class="line">for i in range(len(data)):</div><div class="line">    for j in range(len(data[i])):# 循环一条记录的每一个属性，存入的字符串形如&quot;0=2&quot;，代表第一个属性在第二个划分区间里的次数</div><div class="line">        if(cateVec[i]==0): # 如果未幸存</div><div class="line">            if (str(j)+&apos;=&apos;+data[i][j]) in unsurVec:</div><div class="line">                unsurVec[(str(j)+&apos;=&apos;+data[i][j])]+=1</div><div class="line">            else:</div><div class="line">                unsurVec[(str(j)+&apos;=&apos; + data[i][j])] =1</div><div class="line">        else:# 如果幸存</div><div class="line">            if (str(j)+&apos;=&apos;+data[i][j]) in surVec:</div><div class="line">                surVec[(str(j)+&apos;=&apos;+data[i][j])]+=1</div><div class="line">            else:</div><div class="line">                surVec[(str(j)+&apos;=&apos; + data[i][j])] =1</div></pre></td></tr></table></figure></p>
<p><strong>将次数除以类别出现的次数即为相应的先验概率（P（ai=j|C=k））</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"># 对于储存的每一个值除以类别的概率即为P（ai=j|C=k）</div><div class="line">    for key in unsurVec.keys():</div><div class="line">        targetStr = key[key.find(&apos;|&apos;) + 1:]</div><div class="line">        unsurVec[key]/=(len(cateVec) * (1 - surRate))</div><div class="line"></div><div class="line">    for key in surVec.keys():</div><div class="line">        targetStr = key[key.find(&apos;|&apos;) + 1:]</div><div class="line">        surVec[key]/=(len(cateVec) * surRate)</div><div class="line">    return unsurVec,surVec,surRate</div></pre></td></tr></table></figure></p>
<h2 id="识别部分"><a href="#识别部分" class="headerlink" title="识别部分"></a>识别部分</h2><p>识别部分将输入的向量构造成形如字典存储的”0=2”的形式，代表第0个属性值为2（处于第二个划分），再到不同类别的概率字典中取出值乘以类别的概率，即（P（ai=j|C=k）*（P（C=k）））为贝叶斯公式的分子，因为分母相同，取分子最大的类别即为结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">def classify(feature,unsurVec,surVec,survivedRate):</div><div class="line">    # 初始化结果概率</div><div class="line">    survivedPos=1</div><div class="line">    unsurvivedPos=1</div><div class="line">    # 对于每一个属性，计算P(ai=j|C=k)，并将结果乘入对应类别的结果概率</div><div class="line">    for i in range(len(feature)):</div><div class="line">        tempStr=str(i)+&apos;=&apos;+feature[i]</div><div class="line">        survivedPos*=surVec[tempStr]</div><div class="line">        unsurvivedPos*=unsurVec[tempStr]</div><div class="line">    # 计算P(ai=j|C=k)*P（C=k）</div><div class="line">    survivedPos*=survivedRate</div><div class="line">    unsurvivedPos*=(1-survivedRate)</div><div class="line">    # 返回概率大的类别</div><div class="line">    return 1 if survivedPos&gt;unsurvivedPos else 0</div></pre></td></tr></table></figure></p>
<h2 id="主程序调用"><a href="#主程序调用" class="headerlink" title="主程序调用"></a>主程序调用</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div><div class="line">55</div></pre></td><td class="code"><pre><div class="line">data,survived=preProcess()</div><div class="line">unsurVec,surVec,surRate=train(data,survived)</div><div class="line">k=0 # 准确的个数</div><div class="line">total=92 # 测试个数</div><div class="line"></div><div class="line"># 对输入数据预处理，得到与dataMatrix相同的数据格式</div><div class="line">reader=csv.reader(open(&quot;test.csv&quot;))</div><div class="line">for id, sur, pc, name, sex, age, sib, par, tic, fare, car, emb in reader:</div><div class="line">    if (id == &apos;PassengerId&apos;):</div><div class="line">        continue</div><div class="line"></div><div class="line">    temp = [pc, sex, age, sib, par]</div><div class="line">    for i in range(len(temp)):</div><div class="line">        if (len(temp[i]) == 0):</div><div class="line">            temp[i] = 1</div><div class="line"></div><div class="line">    age = float(temp[2])</div><div class="line">    sib = int(temp[3])</div><div class="line">    par = int(temp[4])</div><div class="line"></div><div class="line">    ageTemp = &apos;0&apos;</div><div class="line">    if 0 &lt; age and age &lt; 10:</div><div class="line">        ageTemp = &apos;1&apos;</div><div class="line">    elif 10 &lt;= age &lt; 20:</div><div class="line">        ageTemp = &apos;2&apos;</div><div class="line">    elif 20 &lt;= age &lt; 30:</div><div class="line">        ageTemp = &apos;3&apos;</div><div class="line">    elif 30 &lt;= age &lt; 40:</div><div class="line">        ageTemp = &apos;4&apos;</div><div class="line">    elif age &gt;= 40:</div><div class="line">        ageTemp = &apos;5&apos;</div><div class="line"></div><div class="line">    sibspTemp = &apos;0&apos;</div><div class="line">    if sib == 1:</div><div class="line">        sibspTemp = &apos;1&apos;</div><div class="line">    elif sib == 2:</div><div class="line">        sibspTemp = &apos;2&apos;</div><div class="line">    elif sib &gt; 2:</div><div class="line">        sibspTemp = &apos;3&apos;</div><div class="line"></div><div class="line">    parchTemp = &apos;0&apos;</div><div class="line">    if par == 1:</div><div class="line">        parchTemp = &apos;1&apos;</div><div class="line">    elif par == 2:</div><div class="line">        parchTemp = &apos;2&apos;</div><div class="line">    elif par &gt; 2:</div><div class="line">        parchTemp = &apos;3&apos;</div><div class="line"></div><div class="line">    temp = [pc, &apos;1&apos; if sex == &apos;male&apos; else &apos;0&apos;, ageTemp, sibspTemp, parchTemp]</div><div class="line">    # 判断识别结果</div><div class="line">    if(classify(temp,unsurVec,surVec,surRate)==int(sur)):</div><div class="line">        k+=1</div><div class="line"></div><div class="line"># 输出识别率        </div><div class="line">print(k/total)</div></pre></td></tr></table></figure>
<p><strong><a href="https://github.com/whatseven/nbm-base.git" target="_blank" rel="external">Github项目地址</a></strong></p>
<h1 id="Todo"><a href="#Todo" class="headerlink" title="Todo"></a>Todo</h1><p>对于先验概率的储存还是不太满意，应该会有更好的数据结构用来存储对于每一个类别，每一个属性的每一个划分的值</p>
<p>#参考资料：</p>
<blockquote>
<p><a href="http://www.cnblogs.com/leoo2sk/archive/2010/09/17/naive-bayesian-classifier.html" target="_blank" rel="external">算法杂货铺——分类算法之朴素贝叶斯分类(Naive Bayesian classification)</a></p>
</blockquote>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;朴素贝叶斯算法总结&quot;&gt;&lt;a href=&quot;#朴素贝叶斯算法总结&quot; class=&quot;headerlink&quot; title=&quot;朴素贝叶斯算法总结&quot;&gt;&lt;/a&gt;朴素贝叶斯算法总结&lt;/h1&gt;&lt;p&gt;(有关朴素贝叶斯算法的原理可可参考&lt;a href=&quot;http://www.cnblo
    
    </summary>
    
      <category term="Machine Learning" scheme="http://http://blog.llsevenr.cn/categories/Machine-Learning/"/>
    
    
      <category term="Computer Vision" scheme="http://http://blog.llsevenr.cn/tags/Computer-Vision/"/>
    
      <category term="Machine Lerning" scheme="http://http://blog.llsevenr.cn/tags/Machine-Lerning/"/>
    
      <category term="Python" scheme="http://http://blog.llsevenr.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>搭建Git服务器及多人协作开发常见命令</title>
    <link href="http://http://blog.llsevenr.cn/2017/08/10/%E6%90%AD%E5%BB%BAGit%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%8A%E5%A4%9A%E4%BA%BA%E5%8D%8F%E4%BD%9C%E5%BC%80%E5%8F%91%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4/"/>
    <id>http://http://blog.llsevenr.cn/2017/08/10/搭建Git服务器及多人协作开发常见命令/</id>
    <published>2017-08-10T10:35:59.000Z</published>
    <updated>2017-08-11T14:12:48.911Z</updated>
    
    <content type="html"><![CDATA[<h1 id="搭建Git服务器"><a href="#搭建Git服务器" class="headerlink" title="搭建Git服务器"></a>搭建Git服务器</h1><p>Github的项目必须为开放的并且在中国的访问速度如无特殊配置通常访问很慢，于是便想在自己的服务器上搭建Git仓库，同时也具备多人协作开发的能力。</p>
<h2 id="配置Git和用户"><a href="#配置Git和用户" class="headerlink" title="配置Git和用户"></a>配置Git和用户</h2><p>首先安装Git</p>
<p><code>sudo apt install git</code></p>
<p>配置单独用来访问仓库的git用户</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">groupadd git</div><div class="line">adduser git -g git</div></pre></td></tr></table></figure>
<h2 id="创建SSL证书登录"><a href="#创建SSL证书登录" class="headerlink" title="创建SSL证书登录"></a>创建SSL证书登录</h2><p>在支持bash的命令行下，输入</p>
<p><code>ssh-keygen -C &#39;your@email.com&#39; -t rsa</code></p>
<p>为你生成rsa密钥，可以直接一路回车，执行默认操作，生成的密钥可以在这儿找到<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">C://users//&lt;电脑账户名&gt;//.ssh</div><div class="line">├── id_rsa</div><div class="line">└── id_rsa.pub #公钥 服务端需要里边内容验证连接着身份</div></pre></td></tr></table></figure></p>
<p>将SSH添加到管理</p>
<p><code>ssh-add id_rsa</code></p>
<p>将公钥里面的内容完整输入至<code>/home/git/.ssh/authorized_keys</code>，一行一个密钥</p>
<h2 id="Tips：多公钥管理"><a href="#Tips：多公钥管理" class="headerlink" title="Tips：多公钥管理"></a>Tips：多公钥管理</h2><p>在<code>.ssh</code>目录下配置<code>config</code>文件，<strong>再将SSH加入SSH管理</strong>，格式如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">Host github.com             //连接域名</div><div class="line">  HostName github.com       //域名名称</div><div class="line">  User whatseven            //用户</div><div class="line">  IdentityFile C:\Users\whatseven\.ssh\id_rsa_github    //对应私钥</div><div class="line">  PreferredAuthentications publickey</div></pre></td></tr></table></figure></p>
<h1 id="Git多人协作开发常用命令"><a href="#Git多人协作开发常用命令" class="headerlink" title="Git多人协作开发常用命令"></a>Git多人协作开发常用命令</h1><p>完成上述步骤，就能够在自己的服务器上建立仓库并且作为远程分支与本地分支建立联系了，下面是在多人协作开发的一些常用的Git命令。</p>
<h2 id="建立裸仓库"><a href="#建立裸仓库" class="headerlink" title="建立裸仓库"></a>建立裸仓库</h2><p>在建好的服务器里新建文件夹，在文件夹下使用<code>git init --bare</code>新建裸仓库，只存放版本库信息。</p>
<p>开发人员A上用<code>git clone 仓库地址 仓库在本机的命名</code>克隆仓库，开始自己的本地开发。</p>
<h3 id="Tips：为什么要建立裸仓库？"><a href="#Tips：为什么要建立裸仓库？" class="headerlink" title="Tips：为什么要建立裸仓库？"></a>Tips：为什么要建立裸仓库？</h3><p>在Git中，如果向普通代码仓库push的话，Git会将推送的内容与工作文件进行比较，它会认为工作文件发生改变，从而影响工作树，常见的是在想远程目标的当前分支push代码时，在远程终端必须使用<code>git reset --hard</code>。而裸代码仓库由于没有工作树，所以push所含的变化仅影响裸代码仓库的版本控制。</p>
<p><strong>在裸仓库中，工作目录下除了版本库信息没有任何东西，会给大家造成一个误解以为裸仓库只记录版本，没有文件。其实在Git系统中，文件是通过不同的对象例如索引，树，块存与版本库里面的，所以裸仓库看似工作目录是空的，在克隆裸仓库是git会将对象从版本库取出并根据版本更改信息组织到正确的位置</strong></p>
<p>在开发过程中，一般会将项目分为几个分支。</p>
<blockquote>
<p><strong>Git分支策略</strong></p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://otbwgn2nv.bkt.clouddn.com/de249adc849a5e3ed721b3f4fc397e4d.png" alt="Git分支策略" title="">
                </div>
                <div class="image-caption">Git分支策略</div>
            </figure>
</blockquote>
<ol>
<li><strong>master</strong>分支应该保存重大的版本或节点，开发前应保持远程与本地同步</li>
<li><strong>dev</strong>是日常开发分支，平时的开发应在dev上进行，开发前应保持远程与本地同步</li>
<li>剩下的是个人分支，个人的开发在个人分支上进行，在每天或者一个阶段的工作结束后每个人将自己的代码合并到dev分支上。个人分支不用同步至远程分支</li>
</ol>
<h2 id="开发实例"><a href="#开发实例" class="headerlink" title="开发实例"></a>开发实例</h2><p>下面通过两个开发人员实例演示多人开发：</p>
<p>开发人员A通过<code>git clone git@111.111.111.111:/home/git/repo/test.git test.git</code>将远程的版本库克隆至本机</p>
<p>如无dev分支，A通过<code>git checkout -b dev</code>从<strong>master</strong>分支创建<strong>dev</strong>分支</p>
<p>A再次通过<code>git checkout -b A</code>从<strong>dev</strong>分支上创建自己的开发分支</p>
<p>A在工作目录里新建内容为”A”的<strong>A.txt</strong>，再创建内容为”公共”的<strong>公共.txt</strong></p>
<p>A通过<code>git add A.txt 公共.txt</code>与<code>git commit -m &quot;init A,公共&quot;</code>提交更改</p>
<p>当A完成阶段性工作后，通过<code>git checkout dev</code>切换至开发分支，再通过<code>git merge --no-ff A</code>将<strong>A</strong>分支合并到<strong>dev</strong>分支,如有冲突则在文件中去删除多余部分</p>
<p>A剩下的工作是要将自己的工作推到大家代码的源头–位于远程的裸仓库中，在Git中，本机Git版本库与远程库的连接是基于分支的，例如本机的<strong>master</strong>与远程的<strong>master</strong>有一条链接，本机的<strong>dev</strong>也应该与远程<strong>dev</strong>有一个链接。</p>
<p>A通过在<strong>dev</strong>分支上<code>git push -u origin dev</code>将本机的<strong>dev</strong>分支的更新推送到远程<strong>dev</strong>分支上去，<code>-u</code>选项是指在未建立链接的情况下建立一条链接，以后推送更新就只用<code>git push</code>即可</p>
<p>此时，A的工作已经全部做完了，当B开始工作时，他必须获取远程库的最新情况以保证自己的工作是建立在最新的工作上的，它可以在建立了链接的情况下通过<code>git pull</code>将远程更新拉到本地，后续操作类似A。</p>
]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;搭建Git服务器&quot;&gt;&lt;a href=&quot;#搭建Git服务器&quot; class=&quot;headerlink&quot; title=&quot;搭建Git服务器&quot;&gt;&lt;/a&gt;搭建Git服务器&lt;/h1&gt;&lt;p&gt;Github的项目必须为开放的并且在中国的访问速度如无特殊配置通常访问很慢，于是便想在自己的
    
    </summary>
    
      <category term="Git" scheme="http://http://blog.llsevenr.cn/categories/Git/"/>
    
    
      <category term="Git" scheme="http://http://blog.llsevenr.cn/tags/Git/"/>
    
      <category term="分支策略" scheme="http://http://blog.llsevenr.cn/tags/%E5%88%86%E6%94%AF%E7%AD%96%E7%95%A5/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript常见集合操作</title>
    <link href="http://http://blog.llsevenr.cn/2017/08/09/JavaScript%E5%B8%B8%E8%A7%81%E9%9B%86%E5%90%88%E6%93%8D%E4%BD%9C/"/>
    <id>http://http://blog.llsevenr.cn/2017/08/09/JavaScript常见集合操作/</id>
    <published>2017-08-09T13:37:20.000Z</published>
    <updated>2017-08-10T13:56:49.058Z</updated>
    
    <content type="html"><![CDATA[<h2 id="集合的遍历"><a href="#集合的遍历" class="headerlink" title="集合的遍历"></a>集合的遍历</h2><h3 id="for循环-效率最高"><a href="#for循环-效率最高" class="headerlink" title="for循环(效率最高)"></a>for循环(效率最高)</h3><ul>
<li>优点：JavaScript最普遍的for循环，执行效率最高</li>
<li>缺点：无法遍历对象</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for(let i=0;i&lt;array.length,i++)&#123;</div><div class="line">    //operation</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="for…in循环-效率较低"><a href="#for…in循环-效率较低" class="headerlink" title="for…in循环(效率较低)"></a>for…in循环(效率较低)</h3><ul>
<li>优点：唯一一个能够获取对象的属性名的遍历方式</li>
<li>缺点：会将对象通过继承得到的属性一齐遍历，造成非预料的结果且效率较低</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">//会访问非继承的属性</div><div class="line">for(attr in object)&#123;//attr作为属性名</div><div class="line">    //object[attr]访问值</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">//避免访问继承的属性</div><div class="line">for(attr in object)&#123;//attr作为属性名</div><div class="line">    if(object.hasOwnProperty(attr))&#123;</div><div class="line">        //object[attr]访问值        </div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="for…of循环-效率较高"><a href="#for…of循环-效率较高" class="headerlink" title="for…of循环(效率较高)"></a>for…of循环(效率较高)</h3><ul>
<li>优点：能够快速访问非继承属性值</li>
<li>缺点：需要ES6支持</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">for(item of object)&#123;</div><div class="line">    //item访问值</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="forEach方法-数组内置高阶方法，含义清晰"><a href="#forEach方法-数组内置高阶方法，含义清晰" class="headerlink" title="forEach方法(数组内置高阶方法，含义清晰)"></a>forEach方法(数组内置高阶方法，含义清晰)</h3><ul>
<li>优点：函数式编程，简洁，快速领会代码含义</li>
<li>缺点：无法对对象使用</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">array.forEach(function(item,index,array))&#123;</div><div class="line">    //item为值</div><div class="line">    //index为索引</div><div class="line">    //array为被访问数组</div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="Tips"><a href="#Tips" class="headerlink" title="Tips:"></a>Tips:</h3><ol>
<li>在对对象进行遍历时，如不需要访问属性名选择<code>for...of</code>循环，如需访问属性名选择<code>for...in</code>循环</li>
<li>在对数组进行访问时，使用<code>forEach</code>得到较好的可读性，传统的<code>for</code>循环能够带来很高的性能及拓展性</li>
</ol>
<h2 id="集合的操作"><a href="#集合的操作" class="headerlink" title="集合的操作"></a>集合的操作</h2><p>在小波老师提倡的想机器一样思考中，编程问题的解决被分为了输入，处理和输出</p>
<blockquote>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="http://otbwgn2nv.bkt.clouddn.com/ddbb7a0501334ed5b6fc3cf6adba1c8c.png" alt="像机器一样思考" title="">
                </div>
                <div class="image-caption">像机器一样思考</div>
            </figure>
<p>引用自<a href="https://www.zybuluo.com/jtong/note/403738" target="_blank" rel="external">像机器一样思考（一）—— 宏观的基础</a></p>
</blockquote>
<p>处理，是对输入数据的处理，就可以分为从输入的数据中提炼出一定的有价值的数据，并对他们做出一些操作，得到希望得到的有价值的东西，并将他输出</p>
<h3 id="Map映射"><a href="#Map映射" class="headerlink" title="Map映射"></a>Map映射</h3><p>Map映射是将输入的数据中有价值的东西提取出来，转化为更有利于处理的格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">let dataAfterProcess = array.map(function(item,index,array)&#123;</div><div class="line">    //item为值</div><div class="line">    //index为索引</div><div class="line">    //array为被访问数组</div><div class="line">    return ;//返回dataAfterProcess中希望被添加的元素</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="Reduce计算"><a href="#Reduce计算" class="headerlink" title="Reduce计算"></a>Reduce计算</h3><p>Reduce计算以提取好的数据输入，并获得最终的<strong>一个</strong>结果<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">let output = array.reduce(function(accumulator, currentValue, currentIndex, array)&#123;</div><div class="line">    //accumulator为输出结果</div><div class="line">    //currentValue为遍历数组目前的值</div><div class="line">    //currentIndex为遍历数组目前的索引</div><div class="line">    //array为被访问数组</div><div class="line">    return ;//返回希望累加的操作</div><div class="line">&#125;,0);//0为计算结果的初始值，默认为数组第一个元素</div></pre></td></tr></table></figure></p>
<h2 id="TODO"><a href="#TODO" class="headerlink" title="TODO"></a>TODO</h2><p>在完成JS练习中，我时常会遇到以下问题待解决：</p>
<ol>
<li>在<code>Map</code>操作中，经常会遇到需要根据已有的目标数组的情况做出相应的映射操作，但目前尚未发现怎样在Map循环中检查已映射的目标数组</li>
<li>为对象实现接口使对象也具有<code>MapReduce</code>操作的能力</li>
</ol>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;集合的遍历&quot;&gt;&lt;a href=&quot;#集合的遍历&quot; class=&quot;headerlink&quot; title=&quot;集合的遍历&quot;&gt;&lt;/a&gt;集合的遍历&lt;/h2&gt;&lt;h3 id=&quot;for循环-效率最高&quot;&gt;&lt;a href=&quot;#for循环-效率最高&quot; class=&quot;headerlink&quot; 
    
    </summary>
    
      <category term="JavaScript" scheme="http://http://blog.llsevenr.cn/categories/JavaScript/"/>
    
    
      <category term="JavaScript" scheme="http://http://blog.llsevenr.cn/tags/JavaScript/"/>
    
      <category term="collection" scheme="http://http://blog.llsevenr.cn/tags/collection/"/>
    
      <category term="集合" scheme="http://http://blog.llsevenr.cn/tags/%E9%9B%86%E5%90%88/"/>
    
      <category term="遍历" scheme="http://http://blog.llsevenr.cn/tags/%E9%81%8D%E5%8E%86/"/>
    
  </entry>
  
</feed>
